import { ethers } from "ethers";
import axios from "axios";

const GRAVITY_RPC =
  process.env.GRAVITY_RPC || "https://evmrpc-testnet.0g.ai";
const EXPLORER_API =
  process.env.EXPLORER_API ||
  "https://chainscan-galileo.0g.ai/v1/transaction";

const provider = new ethers.JsonRpcProvider(GRAVITY_RPC);

const erc20Abi = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)",
];

// optional token addresses if you know them
const tokenList = [
  // add known tokens here if you have them
];

export default async function handler(req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  if (req.method === "OPTIONS") return res.status(200).end();

  try {
    const { address } = req.query;
    if (!address || !ethers.isAddress(address))
      return res.status(400).json({ error: "Invalid wallet address" });

    // ✅ Native balance
    const nativeBalance = await provider.getBalance(address);
    const formattedNative = ethers.formatEther(nativeBalance);

    // ✅ Token balances
    const tokens = [];
    for (const token of tokenList) {
      const contract = new ethers.Contract(token.address, erc20Abi, provider);
      const balance = await contract.balanceOf(address);
      const decimals = await contract.decimals();
      tokens.push({
        name: await contract.name(),
        symbol: await contract.symbol(),
        balance: Number(ethers.formatUnits(balance, decimals)).toFixed(4),
      });
    }

    // ✅ Fetch all transactions (pagination loop)
    let allTxs = [];
    let skip = 0;
    const limit = 100;

    while (true) {
      const url = `${EXPLORER_API}?accountAddress=${address}&limit=${limit}&skip=${skip}`;
      const resp = await axios.get(url);
      const txs = resp.data?.data || resp.data?.transactions || [];

      if (!Array.isArray(txs) || txs.length === 0) break;
      allTxs = allTxs.concat(txs);

      if (txs.length < limit) break;
      skip += limit;
    }

    // ✅ Extract stats
    const totalTx = allTxs.length;
    const sorted = allTxs.sort(
      (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
    );
    const firstTxDate = sorted[0]?.timestamp
      ? new Date(sorted[0].timestamp * 1000).toLocaleString()
      : "N/A";

    // ✅ NFTs (placeholder — depends on explorer endpoint)
    // if endpoint available: GET /v1/nfts?owner=address
    const nftHoldings = [];

    return res.status(200).json({
      network: "Gravity Network Testnet",
      address,
      rpc: GRAVITY_RPC,
      nativeBalance: formattedNative,
      totalTransactions: totalTx,
      firstTxDate,
      tokens,
      nftHoldings,
      txHistory: allTxs.slice(-10).reverse(), // last 10 shown
    });
  } catch (err) {
    console.error("Error fetching wallet data:", err);
    return res.status(500).json({ error: "Error fetching wallet data" });
  }
}
